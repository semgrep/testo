<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="A hands-on tutorial that introduces Testo step by step. Learn what Testo can do, explore its core features, and get started with practical examples in minutes." />
  <title>Getting Started with Testo: A Hands-On Tutorial</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/reference/odoc.support/odoc.css" />
  <link rel="stylesheet" href="/generic.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Getting Started with Testo: A Hands-On Tutorial</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#main-features" id="toc-main-features">Main
features</a></li>
<li><a href="#recommended-uses" id="toc-recommended-uses">Recommended
uses</a></li>
<li><a href="#getting-started" id="toc-getting-started">Getting
started</a>
<ul>
<li><a href="#install-the-testo-library"
id="toc-install-the-testo-library">Install the <code>testo</code>
library</a></li>
<li><a href="#set-up-your-project" id="toc-set-up-your-project">Set up
your project</a></li>
<li><a href="#inspect-the-existing-tests"
id="toc-inspect-the-existing-tests">Inspect the existing tests</a></li>
<li><a href="#add-a-new-test" id="toc-add-a-new-test">Add a new
test</a></li>
<li><a href="#make-a-test-fail" id="toc-make-a-test-fail">Make a test
fail</a></li>
<li><a href="#make-a-test-check-its-output"
id="toc-make-a-test-check-its-output">Make a test check its
output</a></li>
<li><a href="#check-long-outputs" id="toc-check-long-outputs">Check long
outputs</a></li>
<li><a href="#check-diffs" id="toc-check-diffs">Check diffs</a></li>
</ul></li>
<li><a href="#whats-next" id="toc-whats-next">What’s next?</a></li>
</ul>
</nav>
<h2 id="introduction">Introduction</h2>
<p><a href="../">Testo</a> is a test framework for <a
href="https://ocaml.org/">OCaml</a>. Like with <a
href="https://github.com/gildor478/ounit">OUnit</a> or <a
href="https://github.com/mirage/alcotest">Alcotest</a>, the user writes
a collection of tests. A test consists of a name and an OCaml test
function to run, and supports many options. If the test function
returns, the test is considered successful but if it raises an
exception, it is considered failed.</p>
<p>The test suite is compiled into a test executable with a command-line
interface provided by the Testo library. The test executable is called
manually or by CI jobs to run tests and review the results.</p>
<h2 id="main-features">Main features</h2>
<ul>
<li>Most tests can be defined by providing only a name and a function of
type <code>unit -&gt; unit</code>.</li>
<li>Tests can be placed into categories, subcategories, etc. to make it
easier to work with groups of related tests.</li>
<li>Tests can be tagged so as to select groups of tests independently
from hierarchical categories.</li>
<li>A test suite is always a flat list of tests regardless of categories
or tags.</li>
<li>Tests that are expected to fail (“XFAIL”) can be marked as such.
This allows writing tests ahead of feature implementation or bug
fixes.</li>
<li>Supports output snapshots, i.e. capturing stdout or stderr from a
test and comparing it with a reference file.</li>
<li>Reviewing previous test outcomes can be done without rerunning the
tests.</li>
<li>Provides various utilities for capturing stdout or stderr, and
masking variable parts of test output such as temporary file paths.</li>
<li>Support for tests that return Lwt promises.</li>
<li>Fast parallel execution using multiprocessing.</li>
<li>Non-intrusive support for timeouts.</li>
<li>Support for older OCaml versions starting from OCaml 4.08.</li>
<li>Windows support.</li>
</ul>
<p>XFAIL outcomes and snapshot files are two features borrowed from <a
href="https://docs.pytest.org/">Pytest</a> that would have required
massive changes in Alcotest and led to the creation of a new
project.</p>
<h2 id="recommended-uses">Recommended uses</h2>
<p>Testo was designed to support older OCaml versions starting from 4.08
and to be maintained by the community of users. We’ve been using it to
test <a href="https://github.com/semgrep/semgrep">Semgrep</a> which has
about 7000 OCaml tests, many of which were originally migrated from
Alcotest. Check out the <a
href="https://github.com/semgrep/testo/issues">known missing
features</a> to see if anything critical to you is missing.</p>
<h2 id="getting-started">Getting started</h2>
<h3 id="install-the-testo-library">Install the <code>testo</code>
library</h3>
<p>Installing <code>testo</code> with <a
href="https://opam.ocaml.org/">Opam</a> using
<code>opam install testo</code>.</p>
<h3 id="set-up-your-project">Set up your project</h3>
<p>At this stage, you need an OCaml project that uses Dune and Git.
First, clone <a href="https://github.com/semgrep/testo-template">our
template</a>:</p>
<pre><code>$ git clone https://github.com/semgrep/testo-template.git
$ cd testo-template</code></pre>
<p>Then, check that it works:</p>
<pre><code>$ dune build
$ ./test</code></pre>
<p>This will run the test suite, showing output similar to this:</p>
<pre><code>$ ./test
Legend:
• [PASS]: a successful test that was expected to succeed (good);
• [FAIL]: a failing test that was expected to succeed (needs fixing);
• [XFAIL]: a failing test that was expected to fail (tolerated failure);
• [XPASS]: a successful test that was expected to fail (progress?).
• [MISS]: a test that never ran;
• [SKIP]: a test that is always skipped but kept around for some reason;
• [xxxx*]: a new test for which there&#39;s no expected output yet.
  In this case, you should review the test output and run the &#39;approve&#39;
  subcommand once you&#39;re satisfied with the output.
Try &#39;--help&#39; for options.
[RUN]   5d41402abc4b hello
[PASS]  5d41402abc4b hello
• Path to captured log: _build/testo/status/my_project/5d41402abc4b/log
1/1 selected test:
  1 successful (1 pass, 0 xfail)
  0 unsuccessful (0 fail, 0 xpass)
overall status: success</code></pre>
<h3 id="inspect-the-existing-tests">Inspect the existing tests</h3>
<p><code>tests/test.ml</code> is the entry point for the test suite.
Inspect it and you’ll see:</p>
<ul>
<li>a test suite which is a flat list of test cases. For now, it
contains just one test named <code>hello</code>.</li>
<li>the invocation of <code>Testo.interpret_argv</code>. It is in charge
of interpreting the command line and performing the requested
actions.</li>
</ul>
<h3 id="add-a-new-test">Add a new test</h3>
<p>Copy the existing <code>hello</code> test and call it
<code>"welcome message"</code>. Rebuild and rerun the test suite. You
should now see two successful tests.</p>
<h3 id="make-a-test-fail">Make a test fail</h3>
<p>Make the “welcome message” test fail. For example, you can use this
code:</p>
<pre><code>let test_welcome_message =
  Testo.create &quot;welcome message&quot;
    (fun () -&gt;
       let expected = &quot;welcome&quot; in
       let result = &quot;hello&quot; in
       Testo.(check string) expected result
    )</code></pre>
<p>Run the tests. You should now see a failing test:</p>
<pre><code>...

┌──────────────────────────────────────────────────────────────────────────────┐
│ [FAIL]  504541c02761 welcome message                                         │
└──────────────────────────────────────────────────────────────────────────────┘
• Path to captured log: _build/testo-template/status/my_project/504541c02761/log
• Log (stdout, stderr) is empty.
• Exception raised by the test:
 Test failed: not equal:
   expected (left): &quot;welcome&quot;
   actual  (right): &quot;hello&quot;
 differences:
 --- expected
 +++ actual
 @@ -1,1 +1,1 @@
 -&quot;welcome&quot;
 +&quot;hello&quot;
 
 
────────────────────────────────────────────────────────────────────────────────
[FAIL]  504541c02761 welcome message
2/2 selected tests:
  1 successful (1 pass, 0 xfail)
  1 unsuccessful (1 fail, 0 xpass)
overall status: failure</code></pre>
<h3 id="make-a-test-check-its-output">Make a test check its output</h3>
<p>Now instead of comparing strings, let’s compare the output of some
code that writes to stdout.</p>
<p>Modify the “welcome message” test to print <code>welcome</code> on
stdout:</p>
<pre><code>let test_welcome_message =
  Testo.create &quot;welcome message&quot;
    (fun () -&gt;
       print_endline &quot;welcome&quot;
    )</code></pre>
<p>To check what’s printed on stdout, use
<code>Testo.with_capture</code>:</p>
<pre><code>let test_hello =
  Testo.create &quot;hello&quot;
    (fun () -&gt;
      let (), out =
        Testo.with_capture stdout
          (fun () -&gt; print_endline &quot;welcome&quot;)
      in
      Testo.(check string) &quot;welcome&quot; out
    )</code></pre>
<p>Try it.</p>
<h3 id="check-long-outputs">Check long outputs</h3>
<p>Assume you want to check the help page printed by a program. As an
exercise, use <code>dune --help</code>. The output takes multiple
screens and is cumbersome to copy-paste and escape correctly due to the
presence of special characters:</p>
<pre><code>$ dune --help
DUNE(1)                           Dune Manual                          DUNE(1)



NAME
       dune - composable build system for OCaml

SYNOPSIS
...</code></pre>
<p>It wouldn’t be convenient to store this as a double-quoted string in
our OCaml file <code>test.ml</code>. Testo allows capturing stdout or
stderr as a file or “snapshot” that will serve as a reference for future
runs. Do this with the <code>~checked_output</code> option as
follows:</p>
<pre><code>let test_dune_help =
  Testo.create &quot;dune help&quot;
    ~checked_output:(Testo.stdout ())
    (fun () -&gt; Sys.command &quot;dune --help&quot; |&gt; ignore)</code></pre>
<p>Add it to your test suite.</p>
<p>Run <code>./test</code> with the updated code. It almost works but
reports a failure and tells you that something’s missing:</p>
<pre><code>...
┌──────────────────────────────────────────────────────────────────────────────┐
│ [PASS*] 06e03989d7ca dune help                                               │
└──────────────────────────────────────────────────────────────────────────────┘
• Checked output: stdout
• Missing file containing the expected output: tests/snapshots/my_project/06e03989d7ca/stdout
• Path to captured stdout: _build/testo-template/status/my_project/06e03989d7ca/stdout
• Path to captured log: _build/testo-template/status/my_project/06e03989d7ca/log
• Log (stderr) is empty.
...
1 test whose output needs first-time approval
...</code></pre>
<p>The status <code>PASS*</code> indicates that the test passed but some
user action is needed. This was expected since we don’t have a reference
output for our test. First, we’re going to check that the captured
output is what we were expecting:</p>
<pre><code>$ less _build/testo-template/status/my_project/06e03989d7ca/stdout
DUNE(1)                           Dune Manual                          DUNE(1)



NAME
       dune - composable build system for OCaml
...</code></pre>
<p>To troubleshoot just one test, select it with the <code>-s</code>
(“select”) filter. This will hide the status of any other failing test
while you work on this one:</p>
<pre><code>$ ./test status -s dune
[PASS*] 06e03989d7ca dune help</code></pre>
<p>The test ID can also be used to select a test. Use <code>-a</code>
(“all”) to list the successful tests. Check that the following command
lists the desired test:</p>
<pre><code>$ ./test status -a -s 5d41402abc4b
[PASS]  5d41402abc4b hello</code></pre>
<p>Check out details with the <code>-l</code> (“long output”)
option:</p>
<pre><code>$ ./test status -l
┌──────────────────────────────────────────────────────────────────────────────┐
│ [PASS*] 06e03989d7ca dune help                                               │
└──────────────────────────────────────────────────────────────────────────────┘
• Checked output: stdout
• Missing file containing the expected output: tests/snapshots/my_project/06e03989d7ca/stdout
• Path to captured stdout: _build/testo-template/status/my_project/06e03989d7ca/stdout
• Path to captured log: _build/testo-template/status/my_project/06e03989d7ca/log
• Log (stderr) is empty.
────────────────────────────────────────────────────────────────────────────────
2/2 selected tests:
  2 successful (2 pass, 0 xfail)
  0 unsuccessful (0 fail, 0 xpass)
1 test whose output needs first-time approval
overall status: failure</code></pre>
<p>Approve the output of “dune help” and make it the reference snapshot
with <code>./test approve</code>:</p>
<pre><code>$ ./test approve
Expected output changed for 1 test.</code></pre>
<p>In practice, you might have several tests requiring approval. To
approve a specific test rather than all of them, use
<code>-s</code>:</p>
<pre><code>$ ./test approve -s 06e03989d7ca
Expected output changed for 1 test.</code></pre>
<p>Check the new status:</p>
<pre><code>$ ./test status
$ echo $?  # check the process exit status
0</code></pre>
<p>An exit status of 0 indicates a full success. This is confirmed by
listing all the tests:</p>
<pre><code>$ ./test status -a
[PASS]  5d41402abc4b hello
[PASS]  504541c02761 welcome message
[PASS]  06e03989d7ca dune help</code></pre>
<p>Now, there should be a snapshot file somewhere in our file system.
Git shows you that <code>tests/snapshots</code> was created:</p>
<pre><code>$ git status
...
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
    tests/snapshots/</code></pre>
<p>The test files are organized as follows:</p>
<pre><code>$ tree tests/
tests/
├── dune
├── snapshots
│   └── my_project
│       └── 06e03989d7ca
│           ├── name
│           └── stdout
└── test.ml

3 directories, 4 files</code></pre>
<p>The path to the captured output for our test is
<code>tests/snapshots/my_project/06e03989d7ca/stdout</code>, as shown in
the original test output.</p>
<p>It would be nicer to have the snapshot file with a good name, say
<code>dune-help.txt</code> next to the test code. Do it by passing the
relevant option to <code>Testo.stdout</code>:</p>
<pre><code>let test_dune_help =
  Testo.create &quot;dune help&quot;
    ~checked_output:
      (Testo.stdout
        ~expected_stdout_path:(Fpath.v &quot;tests/dune-help.txt&quot;) ())
    (fun () -&gt; Sys.command &quot;dune --help&quot; |&gt; ignore)</code></pre>
<p>Re-run everything to get the following file tree:</p>
<pre><code>tests/
├── dune
├── dune-help.txt
├── snapshots
│   └── my_project
└── test.ml</code></pre>
<p>Add all these files including the snapshots to your Git repo:</p>
<pre><code>$ git add tests/
$ git commit -m &#39;Add tests&#39;</code></pre>
<h3 id="check-diffs">Check diffs</h3>
<p>Check what happens if you replace the command
<code>dune --help</code> with <code>dune build --help</code> in
<code>test.ml</code>. The “dune help” test should fail and you should
see a diff against the expected output.</p>
<h2 id="whats-next">What’s next?</h2>
<p>You’re now ready to use Testo. To discover more functionality,
explore our <a href="../howtos">how-tos</a> and consult the <a
href="../reference">reference API</a> for all technical details.</p>
</body>
</html>
