<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Testo howtos</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/testo/reference/odoc.support/odoc.css" />
  <link rel="stylesheet" href="/testo/generic.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Testo howtos</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#how-to-write-an-assertion-without-resorting-to-an-extra-library">How to write an assertion (without resorting to an extra library)?</a></li>
<li><a href="#how-to-write-an-assertion-for-a-value-of-a-simple-type-with-alcotest">How to write an assertion for a value of a simple type with Alcotest?</a></li>
<li><a href="#how-to-write-an-assertion-for-a-custom-type">How to write an assertion for a custom type?</a></li>
<li><a href="#how-to-write-tests-ahead-of-time">How to write tests ahead of time?</a></li>
<li><a href="#how-to-write-tests-for-lwt-async-or-other-kinds-of-promises">How to write tests for Lwt, Async or other kinds of promises?</a></li>
<li><a href="#how-to-export-test-output-to-junit">How to export test output to JUnit?</a></li>
<li><a href="#how-to-run-tests-in-parallel">How to run tests in parallel?</a></li>
</ul>
</nav>
<!-- note to authors:
We don't have automatic validation of the code snippets shown here.
It's a good idea to check that your code at least compiles.
For this, you may want to use `dune utop` and paste your code into it.
-->
<p>For getting started with <a href="https://github.com/semgrep/testo">Testo</a> and discovering the basics, make sure to read the <a href="../tutorial">tutorial</a> first.</p>
<h2 id="how-to-write-an-assertion-without-resorting-to-an-extra-library">How to write an assertion (without resorting to an extra library)?</h2>
<p>A simple solution is to use the built-in <code>assert</code> construct:</p>
<pre><code>let test_addition =
  Testo.create &quot;addition&quot;
    (fun () -&gt;
      let res = 1 + 1 in
      assert (res = 2);
      let res = 2 + 2 in
      assert (res = 4)
    )</code></pre>
<p>When such a test fails, the location of the <code>assert ...</code> expression is shown to the user. The advantage over using a dedicated function like <code>Alcotest.check</code> is that it‚Äôs a little quicker to write and simpler to understand. The main disadvantage is that the expected and actual values are not printed. In this case, it‚Äôs best for the test to print enough information about the condition being tested e.g.</p>
<pre><code>open Printf

let test_addition =
  Testo.create &quot;addition&quot;
    (fun () -&gt;
      let add a b expected_result =
        let res = a + b in
        printf &quot;checking %i + %i, expecting %i, result is %i.\n&quot;
          a b expected_result res;
        assert (res = expected_result)
      in
      add 1 1 2;
      add 2 2 4
    )</code></pre>
<p>In case of a failure, the test‚Äôs output will be shown to the user.</p>
<h2 id="how-to-write-an-assertion-for-a-value-of-a-simple-type-with-alcotest">How to write an assertion for a value of a simple type with Alcotest?</h2>
<p>Testo was originally meant to extend <a href="https://github.com/mirage/alcotest">Alcotest</a>, but it became too different and ended up being a separate project. However, Alcotest provides some functionality that wasn‚Äôt reimplemented in Testo and can benefit Testo tests. Like Testo, Alcotest is an ordinary OCaml library that is typically installed with Opam:</p>
<pre><code>$ opam install alcotest</code></pre>
<p><code>Alcotest.check</code> is the function we‚Äôll use to check test results against expectations. If a check fails, an exception is raised and it is formatted as a nice error message.</p>
<p>Here‚Äôs a test that checks values of type <code>int</code>:</p>
<pre><code>let test_addition =
  Testo.create &quot;addition&quot;
    (fun () -&gt;
      let res = 1 + 1 in
      Alcotest.check Alcotest.int &quot;sum&quot; 2 res;
      let res = 2 + 2 in
      Alcotest.check Alcotest.int &quot;sum&quot; 4 res
    )</code></pre>
<p>It is more compactly written as:</p>
<pre><code>let test_addition =
  Testo.create &quot;addition&quot;
    (fun () -&gt;
      let res = 1 + 1 in
      Alcotest.(check int) &quot;sum&quot; 2 res;
      let res = 2 + 2 in
      Alcotest.(check int) &quot;sum&quot; 4 res
    )</code></pre>
<p><code>Alcotest.int</code> is called a <a href="https://mirage.github.io/alcotest/alcotest/Alcotest/index.html#testable-values">‚Äútestable‚Äù</a>. There are predefined testables for OCaml‚Äôs simple types such as <code>bool</code>, <code>int</code>, <code>string</code>, etc.</p>
<p>Checking a list of strings can be done as follows:</p>
<pre><code>let test_items =
   Testo.create &quot;items&quot;
     (fun () -&gt;
       let res = [&quot;a&quot;] @ [&quot;b&quot;] in
       Alcotest.(check (list string)) &quot;sum&quot; [&quot;a&quot;; &quot;b&quot;] res
     )</code></pre>
<h2 id="how-to-write-an-assertion-for-a-custom-type">How to write an assertion for a custom type?</h2>
<p>A testable (see previous section) must be created for types such as records or variants. This is done with <code>Alcotest.testable print equal</code> where <code>print</code> is a printer and <code>equal</code> is an equality function.</p>
<p>Let‚Äôs assume we‚Äôre testing values of type <code>Thing.t</code>. Module <code>Thing</code> exposes the following signature:</p>
<pre><code>module Thing : sig
  type t
  val to_string : t -&gt; string
  val compare : t -&gt; t -&gt; int
  ...
end</code></pre>
<p>The test program will define a testable as follows:</p>
<pre><code>let print_thing fmt x = Format.pp_print_string fmt (Thing.to_string x)
let equal_thing a b = (Thing.compare a b = 0)
let thing = Alcotest.testable print_thing equal_thing</code></pre>
<p>A test function will call <code>Alcotest.check</code> as follows:</p>
<pre><code>let test_things =
  Testo.create
    &quot;things&quot;
    (fun () -&gt;
      let result = ... in
      let expected_thing = ... in
      Alcotest.check thing &quot;equal&quot; expected_thing result
    )</code></pre>
<h2 id="how-to-write-tests-ahead-of-time">How to write tests ahead of time?</h2>
<p>Testo supports two ways of writing tests that are known to fail. If the test consistently fails in all environments, the recommended solution is to use <code>~expected_outcome:(Should_fail "&lt;insert excuse&gt;")</code>:</p>
<pre><code>Testo.create
  &quot;my test&quot;
    ~expected_outcome:(Should_fail &quot;TODO&quot;)
    (fun () -&gt;
      (* code that raises an exception *)
      ...
    )</code></pre>
<p>If such a test raises an exception as expected, its status will be shown as <code>XFAIL</code> and considered successful.</p>
<p>Now, if a test is ‚Äúflaky‚Äù i.e.¬†it sometimes fails and sometimes succeed, it can be marked as ‚Äúskipped‚Äù. The only difference with a test that‚Äôs completely removed from the test suite is that it‚Äôs still listed by <code>./test status -a</code> and marked as <code>SKIP</code> instead of being invisible and forgotten. In this example, we‚Äôll skip a test only if the platform is Windows:</p>
<pre><code>let is_windows =
  Sys.os_type = &quot;Win32&quot;

let test_something =
  (* We don&#39;t run this test on Windows because &lt;reasons&gt; *)
  Testo.create
    &quot;something&quot;
    ~skipped:is_windows
    (fun () -&gt; ...)</code></pre>
<h2 id="how-to-write-tests-for-lwt-async-or-other-kinds-of-promises">How to write tests for Lwt, Async or other kinds of promises?</h2>
<p>The simplest way is to start and stop the event loop within each test. With <code>Lwt</code>, this is normally done with <code>Lwt_main.run</code>:</p>
<pre><code>(* Generic higher-level function that converts a asynchronous
   computation into a synchronous one. *)
let sync (func : unit -&gt; unit Lwt.t) =
  fun () -&gt;
    Lwt_main.run func

let test_sleep () : unit Lwt.t =
  Lwt_unix.sleep 0.05

let tests = [
  Testo.create &quot;sleep&quot; (sync test_sleep);
]</code></pre>
<p>On some platforms such as a JavaScript runtime, there is no equivalent of <code>Lwt_main.run</code>. For these cases, we provide the library <code>testo-lwt</code>. It exposes a <a href="https://semgrep.github.io/testo/reference/testo-lwt/index.html"><code>Testo_lwt</code> module</a> whose interface is almost identical to <code>Testo</code> except that test functions have type <code>unit -&gt; unit Lwt.t</code> instead of <code>unit -&gt; unit</code>.</p>
<p>For the Async library, we don‚Äôt provide <code>testo-async</code> but it should be straightforward to add. Check the status of the <a href="https://github.com/semgrep/testo/issues/73">corresponding GitHub issue</a>.</p>
<h2 id="how-to-export-test-output-to-junit">How to export test output to JUnit?</h2>
<p>üöß not implemented, see <a href="https://github.com/semgrep/testo/issues/14">Issue #14</a>.</p>
<h2 id="how-to-run-tests-in-parallel">How to run tests in parallel?</h2>
<p>üöß not implemented, see <a href="https://github.com/semgrep/testo/issues/8">Issue #8</a>.</p>
</body>
</html>
