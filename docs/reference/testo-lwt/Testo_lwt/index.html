<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Testo_lwt (testo-lwt.Testo_lwt)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">testo-lwt</a> &#x00BB; Testo_lwt</nav><header class="odoc-preamble"><h1>Module <code><span>Testo_lwt</span></code></h1><p>Testo library - Utilities for writing OCaml test suites</p></header><nav class="odoc-toc"><ul><li><a href="#internal-types">Internal types</a></li><li><a href="#main-interface">Main interface</a><ul><li><a href="#test-creation">Test creation</a></li><li><a href="#assertions-and-exceptions">Assertions and exceptions</a></li><li><a href="#temporary-files-and-output-redirection">Temporary files and output redirection</a></li><li><a href="#environment-control">Environment control</a></li><li><a href="#output-masking-functions">Output masking functions</a></li><li><a href="#inline-tests">Inline tests</a></li><li><a href="#categorization-and-filtering-of-test-suites">Categorization and filtering of test suites</a></li><li><a href="#conversion-to-alcotest-test-suites">Conversion to Alcotest test suites</a></li><li><a href="#command-line-interpretation">Command-line interpretation</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="internal-types"><a href="#internal-types" class="anchor"></a>Internal types</h2><p>These types are documented in the library's source code in <code>Types.ml</code>. They are subject to frequent and unannounced changes at the whim of the library's authors. A casual user should not need them.</p><div class="odoc-spec"><div class="spec type anchored" id="type-expected_outcome"><a href="#type-expected_outcome" class="anchor"></a><code><span><span class="keyword">type</span> expected_outcome</span><span> = </span></code><ol><li id="type-expected_outcome.Should_succeed" class="def variant constructor anchored"><a href="#type-expected_outcome.Should_succeed" class="anchor"></a><code><span>| </span><span><span class="constructor">Should_succeed</span></span></code></li><li id="type-expected_outcome.Should_fail" class="def variant constructor anchored"><a href="#type-expected_outcome.Should_fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Should_fail</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>explains why we expect this test to fail</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-outcome"><a href="#type-outcome" class="anchor"></a><code><span><span class="keyword">type</span> outcome</span><span> = </span></code><ol><li id="type-outcome.Succeeded" class="def variant constructor anchored"><a href="#type-outcome.Succeeded" class="anchor"></a><code><span>| </span><span><span class="constructor">Succeeded</span></span></code></li><li id="type-outcome.Failed" class="def variant constructor anchored"><a href="#type-outcome.Failed" class="anchor"></a><code><span>| </span><span><span class="constructor">Failed</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-captured_output"><a href="#type-captured_output" class="anchor"></a><code><span><span class="keyword">type</span> captured_output</span><span> = </span></code><ol><li id="type-captured_output.Ignored" class="def variant constructor anchored"><a href="#type-captured_output.Ignored" class="anchor"></a><code><span>| </span><span><span class="constructor">Ignored</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>unchecked combined output</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_stdout" class="def variant constructor anchored"><a href="#type-captured_output.Captured_stdout" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_stdout</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stdout, unchecked output</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_stderr" class="def variant constructor anchored"><a href="#type-captured_output.Captured_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_stderr</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stderr, unchecked output</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_stdout_stderr" class="def variant constructor anchored"><a href="#type-captured_output.Captured_stdout_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_stdout_stderr</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stdout, stderr</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_merged" class="def variant constructor anchored"><a href="#type-captured_output.Captured_merged" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_merged</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>combined output</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expected_output"><a href="#type-expected_output" class="anchor"></a><code><span><span class="keyword">type</span> expected_output</span><span> = </span></code><ol><li id="type-expected_output.Ignored" class="def variant constructor anchored"><a href="#type-expected_output.Ignored" class="anchor"></a><code><span>| </span><span><span class="constructor">Ignored</span></span></code></li><li id="type-expected_output.Expected_stdout" class="def variant constructor anchored"><a href="#type-expected_output.Expected_stdout" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_stdout</span> <span class="keyword">of</span> string</span></code></li><li id="type-expected_output.Expected_stderr" class="def variant constructor anchored"><a href="#type-expected_output.Expected_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_stderr</span> <span class="keyword">of</span> string</span></code></li><li id="type-expected_output.Expected_stdout_stderr" class="def variant constructor anchored"><a href="#type-expected_output.Expected_stdout_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_stdout_stderr</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stdout, stderr</p><span class="comment-delim">*)</span></div></li><li id="type-expected_output.Expected_merged" class="def variant constructor anchored"><a href="#type-expected_output.Expected_merged" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_merged</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>combined output</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-result"><a href="#type-result" class="anchor"></a><code><span><span class="keyword">type</span> result</span><span> = </span><span>{</span></code><ol><li id="type-result.outcome" class="def record field anchored"><a href="#type-result.outcome" class="anchor"></a><code><span>outcome : <a href="#type-outcome">outcome</a>;</span></code></li><li id="type-result.captured_output" class="def record field anchored"><a href="#type-result.captured_output" class="anchor"></a><code><span>captured_output : <a href="#type-captured_output">captured_output</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-missing_files"><a href="#type-missing_files" class="anchor"></a><code><span><span class="keyword">type</span> missing_files</span><span> = </span></code><ol><li id="type-missing_files.Missing_files" class="def variant constructor anchored"><a href="#type-missing_files.Missing_files" class="anchor"></a><code><span>| </span><span><span class="constructor">Missing_files</span> <span class="keyword">of</span> <span><span class="xref-unresolved">Fpath</span>.t list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expectation"><a href="#type-expectation" class="anchor"></a><code><span><span class="keyword">type</span> expectation</span><span> = </span><span>{</span></code><ol><li id="type-expectation.expected_outcome" class="def record field anchored"><a href="#type-expectation.expected_outcome" class="anchor"></a><code><span>expected_outcome : <a href="#type-expected_outcome">expected_outcome</a>;</span></code></li><li id="type-expectation.expected_output" class="def record field anchored"><a href="#type-expectation.expected_output" class="anchor"></a><code><span>expected_output : <span><span>(<a href="#type-expected_output">expected_output</a>, <a href="#type-missing_files">missing_files</a>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> status</span><span> = </span><span>{</span></code><ol><li id="type-status.expectation" class="def record field anchored"><a href="#type-status.expectation" class="anchor"></a><code><span>expectation : <a href="#type-expectation">expectation</a>;</span></code></li><li id="type-status.result" class="def record field anchored"><a href="#type-status.result" class="anchor"></a><code><span>result : <span><span>(<a href="#type-result">result</a>, <a href="#type-missing_files">missing_files</a>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-fail_reason"><a href="#type-fail_reason" class="anchor"></a><code><span><span class="keyword">type</span> fail_reason</span><span> = </span></code><ol><li id="type-fail_reason.Exception" class="def variant constructor anchored"><a href="#type-fail_reason.Exception" class="anchor"></a><code><span>| </span><span><span class="constructor">Exception</span></span></code></li><li id="type-fail_reason.Wrong_output" class="def variant constructor anchored"><a href="#type-fail_reason.Wrong_output" class="anchor"></a><code><span>| </span><span><span class="constructor">Wrong_output</span></span></code></li><li id="type-fail_reason.Exception_and_wrong_output" class="def variant constructor anchored"><a href="#type-fail_reason.Exception_and_wrong_output" class="anchor"></a><code><span>| </span><span><span class="constructor">Exception_and_wrong_output</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status_class"><a href="#type-status_class" class="anchor"></a><code><span><span class="keyword">type</span> status_class</span><span> = </span></code><ol><li id="type-status_class.PASS" class="def variant constructor anchored"><a href="#type-status_class.PASS" class="anchor"></a><code><span>| </span><span><span class="constructor">PASS</span></span></code></li><li id="type-status_class.FAIL" class="def variant constructor anchored"><a href="#type-status_class.FAIL" class="anchor"></a><code><span>| </span><span><span class="constructor">FAIL</span> <span class="keyword">of</span> <a href="#type-fail_reason">fail_reason</a></span></code></li><li id="type-status_class.XFAIL" class="def variant constructor anchored"><a href="#type-status_class.XFAIL" class="anchor"></a><code><span>| </span><span><span class="constructor">XFAIL</span> <span class="keyword">of</span> <a href="#type-fail_reason">fail_reason</a></span></code></li><li id="type-status_class.XPASS" class="def variant constructor anchored"><a href="#type-status_class.XPASS" class="anchor"></a><code><span>| </span><span><span class="constructor">XPASS</span></span></code></li><li id="type-status_class.MISS" class="def variant constructor anchored"><a href="#type-status_class.MISS" class="anchor"></a><code><span>| </span><span><span class="constructor">MISS</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status_summary"><a href="#type-status_summary" class="anchor"></a><code><span><span class="keyword">type</span> status_summary</span><span> = </span><span>{</span></code><ol><li id="type-status_summary.status_class" class="def record field anchored"><a href="#type-status_summary.status_class" class="anchor"></a><code><span>status_class : <a href="#type-status_class">status_class</a>;</span></code></li><li id="type-status_summary.has_expected_output" class="def record field anchored"><a href="#type-status_summary.has_expected_output" class="anchor"></a><code><span>has_expected_output : bool;</span></code></li></ol><code><span>}</span></code></div></div><h2 id="main-interface"><a href="#main-interface" class="anchor"></a>Main interface</h2><h3 id="test-creation"><a href="#test-creation" class="anchor"></a>Test creation</h3><div class="odoc-spec"><div class="spec type anchored" id="type-checked_output_kind"><a href="#type-checked_output_kind" class="anchor"></a><code><span><span class="keyword">type</span> checked_output_kind</span></code></div><div class="spec-doc"><p>This type specifies what part of the output of a test (stdout, stderr) should be captured and compared against expectations.</p><p>Use the provided functions <a href="#val-stdout"><code>stdout</code></a>, <a href="#val-stderr"><code>stderr</code></a>, <a href="#val-stdxxx"><code>stdxxx</code></a>, and <a href="#val-split_stdout_stderr"><code>split_stdout_stderr</code></a> to create such an object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <span><span class="optlabel">?expected_stdout_path</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Create an object of type <a href="#type-checked_output_kind"><code>checked_output_kind</code></a> specifying that the test's standard output must be checked against a reference file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <span><span class="optlabel">?expected_stderr_path</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-stdout"><code>stdout</code></a> but for capturing stderr instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stdxxx"><a href="#val-stdxxx" class="anchor"></a><code><span><span class="keyword">val</span> stdxxx : <span><span class="optlabel">?expected_stdxxx_path</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-stdout"><code>stdout</code></a> but for capturing the combined stdout and stderr outputs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_stdout_stderr"><a href="#val-split_stdout_stderr" class="anchor"></a><code><span><span class="keyword">val</span> split_stdout_stderr : 
  <span><span class="optlabel">?expected_stdout_path</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_stderr_path</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-stdxxx"><code>stdxxx</code></a> but keep stdout and stderr separate.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Promise/index.html">Promise</a></span></code></div><div class="spec-doc"><p>Wrapper allowing for asynchronous test functions (Lwt and such).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Tag"><a href="#module-Tag" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Tag/index.html">Tag</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../testo-util/Testo_util/Tag/index.html">Testo_util.Tag</a></span></code></div><div class="spec-doc"><p>The type of tags which can be used to define subsets of tests precisely.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> </span><span>{</span></code><ol><li id="type-t.id" class="def record field anchored"><a href="#type-t.id" class="anchor"></a><code><span>id : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Hash of the full name of the test, computed automatically.</p><span class="comment-delim">*)</span></div></li><li id="type-t.internal_full_name" class="def record field anchored"><a href="#type-t.internal_full_name" class="anchor"></a><code><span>internal_full_name : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Full name of the test, derived automatically from category and name.</p><span class="comment-delim">*)</span></div></li><li id="type-t.category" class="def record field anchored"><a href="#type-t.category" class="anchor"></a><code><span>category : <span>string list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Categories are made for organizing tests as a tree which is useful for display and filtering. A new category is created typically when grouping multiple test suites into one with 'categorize_suites' or when assigning a category to a list of tests with 'categorize'. e.g. <code>[&quot;food&quot;; &quot;fruit&quot;; &quot;kiwi&quot;]</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.name" class="def record field anchored"><a href="#type-t.name" class="anchor"></a><code><span>name : string;</span></code></li><li id="type-t.func" class="def record field anchored"><a href="#type-t.func" class="anchor"></a><code><span>func : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>;</span></code></li><li id="type-t.broken" class="def record field anchored"><a href="#type-t.broken" class="anchor"></a><code><span>broken : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If not <code>None</code>, the <code>broken</code> property causes the test to run normally but it will be ignored when determining the success of the test suite. This allows flaky tests to be kept around until they can be fixed. Use the string argument to explain briefly why the test is marked as broken. The <code>--strict</code> command-line option causes the broken status to be ignored i.e. a test run will fail if a broken test fails.</p><span class="comment-delim">*)</span></div></li><li id="type-t.checked_output" class="def record field anchored"><a href="#type-t.checked_output" class="anchor"></a><code><span>checked_output : <a href="#type-checked_output_kind">checked_output_kind</a>;</span></code></li><li id="type-t.expected_outcome" class="def record field anchored"><a href="#type-t.expected_outcome" class="anchor"></a><code><span>expected_outcome : <a href="#type-expected_outcome">expected_outcome</a>;</span></code></li><li id="type-t.normalize" class="def record field anchored"><a href="#type-t.normalize" class="anchor"></a><code><span>normalize : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An optional function to rewrite any output data so as to mask the variable parts.</p><span class="comment-delim">*)</span></div></li><li id="type-t.skipped" class="def record field anchored"><a href="#type-t.skipped" class="anchor"></a><code><span>skipped : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If not <code>None</code>, the <code>skipped</code> property causes a test to be skipped by Alcotest but still shown as <code>&quot;[SKIP]&quot;</code> rather than being omitted. The string should give a reason why the test is being skipped.</p><span class="comment-delim">*)</span></div></li><li id="type-t.solo" class="def record field anchored"><a href="#type-t.solo" class="anchor"></a><code><span>solo : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If not <code>None</code>, this test will never run concurrently with other tests. The string should give a reason why the test should not run in parallel with other tests.</p><span class="comment-delim">*)</span></div></li><li id="type-t.tags" class="def record field anchored"><a href="#type-t.tags" class="anchor"></a><code><span>tags : <span><a href="Tag/index.html#type-t">Tag.t</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tags must be declared once using <code>create_tag</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.tolerate_chdir" class="def record field anchored"><a href="#type-t.tolerate_chdir" class="anchor"></a><code><span>tolerate_chdir : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If the test function changes the current directory without restoring it, it's an error unless this flag is set. All the tests in a test suite should share this field.</p><span class="comment-delim">*)</span></div></li><li id="type-t.tracking_url" class="def record field anchored"><a href="#type-t.tracking_url" class="anchor"></a><code><span>tracking_url : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A link to the relevant entry in a bug tracking system.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p><code>t</code> is the type of a test. A test suite is a flat list of tests.</p><p>A test is at a minimum a name and a test function that raises exceptions to signal test failure. It is created with <a href="#val-create"><code>create</code></a> or other similar functions provided by this module.</p><p>There are two main recommended ways of writing the test function:</p><p>1. With <code>assert false</code>:</p><p>Each test may use <code>assert false</code> to indicate that the test doesn't pass. This is the simplest way of failing while also showing the location of the failure. When using <code>assert false</code>, you should generally take care of printing the expected value and actual value to make debugging easier later.</p><p>2. With <code>Alcotest.(check ...)</code>:</p><p>This is a little nicer because the error messages print something like <code>&quot;Expecting 'foo', got 'bar'&quot;</code>. However, this can make tests slightly more complicated to write. If the test already prints the expected value and the actual value as its output, it's just easier to fail with <code>assert false</code>.</p><p>In any case, Alcotest will capture the output (stdout, stderr) of each test and put it in its own file so we can consult it later. Don't hesitate to log a lot during the execution of the test.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-test_with_status"><a href="#type-test_with_status" class="anchor"></a><code><span><span class="keyword">type</span> test_with_status</span><span> = <a href="#type-t">t</a> * <a href="#type-status">status</a> * <a href="#type-status_summary">status_summary</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-subcommand_result"><a href="#type-subcommand_result" class="anchor"></a><code><span><span class="keyword">type</span> subcommand_result</span><span> = </span></code><ol><li id="type-subcommand_result.Run_result" class="def variant constructor anchored"><a href="#type-subcommand_result.Run_result" class="anchor"></a><code><span>| </span><span><span class="constructor">Run_result</span> <span class="keyword">of</span> <span><a href="#type-test_with_status">test_with_status</a> list</span></span></code></li><li id="type-subcommand_result.Status_result" class="def variant constructor anchored"><a href="#type-subcommand_result.Status_result" class="anchor"></a><code><span>| </span><span><span class="constructor">Status_result</span> <span class="keyword">of</span> <span><a href="#type-test_with_status">test_with_status</a> list</span></span></code></li><li id="type-subcommand_result.Approve_result" class="def variant constructor anchored"><a href="#type-subcommand_result.Approve_result" class="anchor"></a><code><span>| </span><span><span class="constructor">Approve_result</span></span></code></li></ol></div><div class="spec-doc"><p>The return type of each subcommand. It allows custom code to do something with the test data e.g. export to the JUnit format via the optional <code>handle_subcommand_result</code> argument of <code>interpret_argv</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span><span class="optlabel">?broken</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?category</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?checked_output</span>:<a href="#type-checked_output_kind">checked_output_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_outcome</span>:<a href="#type-expected_outcome">expected_outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?normalize</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?skipped</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?solo</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tags</span>:<span><a href="Tag/index.html#type-t">Tag.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tolerate_chdir</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tracking_url</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a test to appear in a test suite.</p><ul><li><code>category</code>: the nested category to assign to the test. The category can be nested further using <a href="#val-categorize"><code>categorize</code></a> or <a href="#val-categorize_suites"><code>categorize_suites</code></a>.</li><li><code>checked_output</code>: determines how to capture the test's output. Defaults to no capture.</li><li><code>expected_outcome</code>: whether a test is expected to complete without raising an exception (default) or by raising an exception.</li><li><code>normalize</code>: a list of functions applied in turn to transform the captured output before comparing it to the reference snapshot. See <a href="#val-mask_line"><code>mask_line</code></a> and other functions with the <code>mask</code> prefix which are provided for this purpose.</li><li><code>skipped</code>: specify that the test must be skipped. This is intended for tests that give inconsistent results and need fixing. The string should explain why the test is being skipped. See also <code>expected_outcome</code>.</li><li><code>solo</code>: specify that the test may not run in concurrently with other tests. The string should explain why.</li><li><code>tags</code>: a list of tags to apply to the test. See <a href="Tag/index.html"><code>Tag</code></a>.</li><li><code>tolerate_chdir</code>: by default, a test will fail if it modifies the current directory and doesn't restore it. This flag cancels this check. Note that Testo will always restore the current directory after running a test regardless of this setting.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : 
  <span><span class="optlabel">?broken</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?category</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?checked_output</span>:<a href="#type-checked_output_kind">checked_output_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_outcome</span>:<a href="#type-expected_outcome">expected_outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?func</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?normalize</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?skipped</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?solo</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tags</span>:<span><a href="Tag/index.html#type-t">Tag.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tolerate_chdir</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tracking_url</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Update some of the test's fields. This ensures that the test's unique identifier <a href="#type-t.id"><code>id</code></a> is recomputed correctly. When specified, an optional property will replace the previous value.</p></div></div><h3 id="assertions-and-exceptions"><a href="#assertions-and-exceptions" class="anchor"></a>Assertions and exceptions</h3><p>Signaling a test failure is done by raising an exception. You may raise any exception to signal a test failure.</p><p>At this time, Testo doesn't provide advanced functions for checking a result against an expected value and printing these values nicely. For these, you may want to use `Alcotest.check` from the <code>alcotest</code> library.</p><div class="odoc-spec"><div class="spec exception anchored" id="exception-Test_failure"><a href="#exception-Test_failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Test_failure</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>The exception raised by <a href="#val-fail"><code>fail</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Raise the <a href="#exception-Test_failure"><code>Test_failure</code></a> exception with a message indicating the reason for the failure.</p></div></div><h3 id="temporary-files-and-output-redirection"><a href="#temporary-files-and-output-redirection" class="anchor"></a>Temporary files and output redirection</h3><div class="odoc-spec"><div class="spec value anchored" id="val-write_file"><a href="#val-write_file" class="anchor"></a><code><span><span class="keyword">val</span> write_file : <span><span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write data to a regular file. Create the file if it doesn't exist. Erase any existing data.</p><p>Usage: <code>write_file path data</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_file"><a href="#val-read_file" class="anchor"></a><code><span><span class="keyword">val</span> read_file : <span><span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Read the contents of a regular file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_temp_file"><a href="#val-with_temp_file" class="anchor"></a><code><span><span class="keyword">val</span> with_temp_file : 
  <span><span class="optlabel">?contents</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?persist</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?prefix</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?suffix</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?temp_dir</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="Promise/index.html#type-t">Promise.t</a></span></span></code></div><div class="spec-doc"><p><code>with_temp_file func</code> creates a temporary file, passes its path to the user-specified function <code>func</code>, and returns the result. The temporary file is deleted when <code>func</code> terminates, even if it raises an exception.</p><p>Options:</p><ul><li><code>contents</code>: data to write to the file. If unspecified, the file is created empty.</li><li><code>persist</code>: if true, the temporary file is not deleted when done as is normally the case. This intended for a user to inspect the file when debugging.</li><li><code>prefix</code>: prefix for the temporary file name. The default is <code>&quot;testo-&quot;</code>.</li><li><code>suffix</code>: a suffix to append to the temporary file name. The default is empty.</li><li><code>temp_dir</code>: the path to the folder where the temporary file must be created. The default is the system default returned by <code>Filename.get_temp_dir_name ()</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_capture"><a href="#val-with_capture" class="anchor"></a><code><span><span class="keyword">val</span> with_capture : 
  <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * string)</span> <a href="Promise/index.html#type-t">Promise.t</a></span></span></code></div><div class="spec-doc"><p><code>with_capture stdout func</code> evaluates <code>func ()</code> while capturing the output of the given channel <code>stdout</code> as a string.</p></div></div><h3 id="environment-control"><a href="#environment-control" class="anchor"></a>Environment control</h3><div class="odoc-spec"><div class="spec value anchored" id="val-with_environment_variables"><a href="#val-with_environment_variables" class="anchor"></a><code><span><span class="keyword">val</span> with_environment_variables : 
  <span><span><span>(string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="Promise/index.html#type-t">Promise.t</a></span></span></code></div><div class="spec-doc"><p><code>with_environment_variables [&quot;FOO&quot;, &quot;42&quot;; &quot;BAR&quot;, &quot;hello&quot;] func</code> sets the environment variables <code>FOO</code> and <code>BAR</code> during the execution of <code>func</code> and then restores them to their original values.</p><p>Additionally, a test failure is produced if <code>func</code> modifies these environment variables without restoring them to the state in which it found them.</p><p>Due to a limitation in OCaml's &quot;Unix&quot; library, environment variables cannot be unset. If an environment variable was originally unset, restoring this original state isn't possible. Instead, the environment variable will be set to the empty string when <code>with_environment_variables</code> returns.</p></div></div><h3 id="output-masking-functions"><a href="#output-masking-functions" class="anchor"></a>Output masking functions</h3><p>Functions with the <code>mask_</code> prefix are string replacement utilities to be used for masking the variable parts of test output in order to make them stable and comparable. This is for the <code>normalize</code> option of <a href="#val-create"><code>create</code></a>.</p><p>Testo will keep a copy of the original, unmasked output for the developer to consult. In particular, this masking functionality will not prevent sensitive data such as passwords or secret keys from being stored in the local file system.</p><div class="odoc-spec"><div class="spec value anchored" id="val-mask_line"><a href="#val-mask_line" class="anchor"></a><code><span><span class="keyword">val</span> mask_line : 
  <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?after</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?before</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Mask partially each line that contains <code>before</code> or <code>after</code>.</p><p>If both <code>after</code> and <code>before</code> are specified, they must occur in that order on a line to have an effect. The text between these markers is replaced by <code>mask</code>. If only <code>before</code> is specified, the portion of masked text starts at the beginning of the line. If only <code>after</code> is specified, the portion of masked text extends to the end of the line.</p><p>For example, <code>(mask_line ~after:&quot;time:&quot; ()) &quot;London time: 10:15,\nBlah&quot;</code> produces <code>&quot;London time:&lt;MASKED&gt;\nBlah&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_pcre_pattern"><a href="#val-mask_pcre_pattern" class="anchor"></a><code><span><span class="keyword">val</span> mask_pcre_pattern : 
  <span><span class="optlabel">?replace</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Mask all occurrences of this PCRE pattern. The syntax is limited to what the ocaml-re library supports.</p><p>In the case that the pattern contains a capturing group and it (the first group) matches, only this substring is replaced rather than the whole match. The default <code>replace</code> function replaces the capture by <code>&quot;&lt;MASKED&gt;&quot;</code>.</p><p>Examples:</p><pre>     (* without a capturing group: *)
     mask_pcre_pattern ~replace:(fun _ -&gt; &quot;X&quot;) {|&lt;[0-9]+&gt;|} &quot;xxx &lt;42&gt; xxx&quot;
       = &quot;xxx X xxx&quot;</pre><pre>     (* with a capturing group: *)
     mask_pcre_pattern ~replace:(fun _ -&gt; &quot;X&quot;) {|&lt;([0-9]+)&gt;|} &quot;xxx &lt;42&gt; xxx&quot;
       = &quot;xxx &lt;X&gt; xxx&quot;</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contains_substring"><a href="#val-contains_substring" class="anchor"></a><code><span><span class="keyword">val</span> contains_substring : <span><span class="label">sub</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Test if a string contains a substring <code>sub</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contains_pcre_pattern"><a href="#val-contains_pcre_pattern" class="anchor"></a><code><span><span class="keyword">val</span> contains_pcre_pattern : <span><span class="label">pat</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Test if a string contains an unanchored PCRE pattern <code>pat</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_lines"><a href="#val-filter_map_lines" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_lines : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Edit or remove each line of text. <code>filter_map_lines edit text</code> applies the function <code>edit</code> in turn to each line of <code>text</code> without its line terminator. Returning <code>None</code> removes the line. Line terminators <code>\n</code> or <code>\r\n</code> are preserved if and only if the line is not removed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_matching_lines"><a href="#val-remove_matching_lines" class="anchor"></a><code><span><span class="keyword">val</span> remove_matching_lines : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>remove_matching_lines cond text</code> removes any line from <code>text</code> that validates <code>cond</code>.</p><p>For example, <code>remove_matching_lines (contains_substring ~sub:&quot;DEBUG&quot;)</code> is a function that removes from a string all the lines containing <code>DEBUG</code>. <code>remove_matching_lines (contains_pcre_pattern ~pat:&quot;^DEBUG&quot;)</code> is a function that removes only the lines that start with <code>DEBUG</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-keep_matching_lines"><a href="#val-keep_matching_lines" class="anchor"></a><code><span><span class="keyword">val</span> keep_matching_lines : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>remove_matching_lines cond text</code> removes any line from <code>text</code> that that doesn't validate <code>cond</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_temp_paths"><a href="#val-mask_temp_paths" class="anchor"></a><code><span><span class="keyword">val</span> mask_temp_paths : 
  <span><span class="optlabel">?depth</span>:<span>int option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?replace</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?temp_dir</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Mask strings that look like temporary file paths. This is useful in the following cases:</p><ul><li>the temporary folder depends on the platform (Unix, Windows) or on the environment (TMPDIR environment variable or equivalent);</li><li>the files placed in the system's temporary folder are assigned random names.</li></ul><p>Options:</p><ul><li><code>depth</code>: maximum number of path segments to mask after <code>/tmp</code> or equivalent. For example, <code>/tmp/b4ac9882/foo/bar</code> will become <code>&lt;TMP&gt;/&lt;MASKED&gt;/foo/bar</code> with the default depth of <code>Some 1</code>. With a depth of 2, if would become <code>&lt;TMP&gt;/&lt;MASKED&gt;/&lt;MASKED&gt;/bar</code>. Use <code>None</code> to mask the full path. Use <code>Some 0</code> to mask only <code>/tmp</code> or equivalent.</li><li><code>replace</code>: function that determines what to replace the matched path with.</li><li><code>temp_dir</code>: the path to the temporary folder to use instead of the system default.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_not_substring"><a href="#val-mask_not_substring" class="anchor"></a><code><span><span class="keyword">val</span> mask_not_substring : <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Keep the given substring and mask everything else. This is for tests that only care about a particular substring being present in the output.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_not_substrings"><a href="#val-mask_not_substrings" class="anchor"></a><code><span><span class="keyword">val</span> mask_not_substrings : <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Keep all the given substrings and mask everything else.</p><p>In case of overlaps between matching substrings, priority is given to the one starting earlier. If two substrings share a prefix, the longest match is preferred.</p><p>Examples:</p><ul><li><code>[&quot;cute&quot;; &quot;exec&quot;]</code> will cause <code>&quot;execute&quot;</code> to become <code>&quot;exec&lt;MASKED&gt;&quot;</code> because <code>exec</code> occurs first in the target string.</li><li><code>[&quot;wat&quot;; &quot;water&quot;]</code> will cause <code>&quot;hard water&quot;</code> to become <code>&quot;&lt;MASKED&gt;water&quot;</code> and not <code>&quot;&lt;MASKED&gt;wat&lt;MASKED&gt;&quot;</code> because <code>water</code> is a longer match than <code>wat</code> starting at the same position.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_not_pcre_pattern"><a href="#val-mask_not_pcre_pattern" class="anchor"></a><code><span><span class="keyword">val</span> mask_not_pcre_pattern : <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Keep the substrings that match the given PCRE pattern and mask everything else.</p></div></div><h3 id="inline-tests"><a href="#inline-tests" class="anchor"></a>Inline tests</h3><div class="odoc-spec"><div class="spec value anchored" id="val-test"><a href="#val-test" class="anchor"></a><code><span><span class="keyword">val</span> test : 
  <span><span class="optlabel">?category</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?checked_output</span>:<a href="#type-checked_output_kind">checked_output_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_outcome</span>:<a href="#type-expected_outcome">expected_outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?normalize</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?skipped</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?solo</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tags</span>:<span><a href="Tag/index.html#type-t">Tag.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tolerate_chdir</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add a test to the global test suite that can be recovered with <a href="#val-get_registered_tests"><code>get_registered_tests</code></a>.</p><p>This mechanism supports only synchronous tests i.e. ordinary tests whose test function has type <code>unit -&gt; unit</code>.</p><p>It is meant to declare inline tests as follows:</p><pre>     let () = Testo.test &quot;foo&quot; (fun () -&gt;
       (* test body raising exceptions to signal failure *)
       ...
     )</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_registered_tests"><a href="#val-get_registered_tests" class="anchor"></a><code><span><span class="keyword">val</span> get_registered_tests : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Recover the list of tests registered with <a href="#val-test"><code>test</code></a>.</p></div></div><h3 id="categorization-and-filtering-of-test-suites"><a href="#categorization-and-filtering-of-test-suites" class="anchor"></a>Categorization and filtering of test suites</h3><p>A Testo test suite is a flat list of test cases. However, each test belongs to a category. Categories can be arbitrarily nested and can be exported as a tree if desired.</p><div class="odoc-spec"><div class="spec value anchored" id="val-categorize"><a href="#val-categorize" class="anchor"></a><code><span><span class="keyword">val</span> categorize : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Put a list of tests into a parent category.</p><p>Usage:</p><pre>     let apple_tests =
       categorize &quot;apples&quot; [test_color; test_juiciness]</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-categorize_suites"><a href="#val-categorize_suites" class="anchor"></a><code><span><span class="keyword">val</span> categorize_suites : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="#type-t">t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Variant of <a href="#val-categorize"><code>categorize</code></a> that flattens the nested list first.</p><pre>     let fruit_tests =
       categorize_suites &quot;fruit&quot; [apple_tests; banana_tests; strawberry_tests]</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Sort tests by category and name, alphabetically.</p><p>Non-ASCII path components are currently sorted by byte order, possibly giving unexpected results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_tag"><a href="#val-has_tag" class="anchor"></a><code><span><span class="keyword">val</span> has_tag : <span><a href="Tag/index.html#type-t">Tag.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Whether a test has this tag. This is meant for filtering test suites.</p></div></div><h3 id="conversion-to-alcotest-test-suites"><a href="#conversion-to-alcotest-test-suites" class="anchor"></a>Conversion to Alcotest test suites</h3><div class="odoc-spec"><div class="spec type anchored" id="type-alcotest_test_case"><a href="#type-alcotest_test_case" class="anchor"></a><code><span><span class="keyword">type</span> alcotest_test_case</span><span> =
  string * <span>[ `Quick <span>| `Slow</span> ]</span> * <span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span></span></code></div><div class="spec-doc"><p>A type alias for Alcotest test cases.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-alcotest_test"><a href="#type-alcotest_test" class="anchor"></a><code><span><span class="keyword">type</span> alcotest_test</span><span> = string * <span><a href="#type-alcotest_test_case">alcotest_test_case</a> list</span></span></code></div><div class="spec-doc"><p>A type alias for an Alcotest <code>test</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_alcotest"><a href="#val-to_alcotest" class="anchor"></a><code><span><span class="keyword">val</span> to_alcotest : <span><span class="label">alcotest_skip</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">_</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-alcotest_test">alcotest_test</a> list</span></span></code></div><div class="spec-doc"><p>Export our tests to a list of tests that can run in Alcotest. This removes the ability to store test outcomes or to check the test output against expectations. Tests that are expected to fail and indeed fail (XFAIL) will be treated as successful by Alcotest. Conversely, tests that fail to raise an exception (XPASS) will be shown as failed by Alcotest.</p><p>This function is provided to facilitate migrations between Alcotest and Testo, not for long-term use. It is independent of the Alcotest library except for the <code>Alcotest.skip</code> function that must be provided via the <code>alcotest_skip</code> argument.</p><p>Usage: <code>Testo.to_alcotest ~alcotest_skip:Alcotest.skip tests</code></p></div></div><h3 id="command-line-interpretation"><a href="#command-line-interpretation" class="anchor"></a>Command-line interpretation</h3><div class="odoc-spec"><div class="spec value anchored" id="val-interpret_argv"><a href="#val-interpret_argv" class="anchor"></a><code><span><span class="keyword">val</span> interpret_argv : 
  <span><span class="optlabel">?argv</span>:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?default_workers</span>:<span>int option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expectation_workspace_root</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?handle_subcommand_result</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subcommand_result">subcommand_result</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?status_workspace_root</span>:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">project_name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span></span></code></div><div class="spec-doc"><p>Launch the command-line interface. It provides subcommands for running the tests, for checking test statuses, and for approving new output.</p><p>A simple call is of the form <code>interpret_argv ~project_name:&quot;my project&quot; create_tests</code> where <code>create_tests</code> is the user-defined function that produces the test suite. <code>create_tests</code> gets called as <code>create_tests env</code> where <code>env</code> is the list of key/value pairs specified on the command line with <code>-e KEY1=VALUE1 -e KEY2=VALUE2 ...</code>. It gives an opportunity to parametrize the tests or to even ignore some tests. Note however that in general, it is preferable for <code>create_tests</code> to always produce the same list of tests regardless of the parameters passed to the program. For skipping a test without making it invisible, use <code>create ~skipped:true</code>. For running a test that is expected to fail, use <code>create ~expected_outcome:(Should_fail &quot;reason&quot;)</code>. For filtering tests in other ways, use tags or search by substring. See <a href="#val-create"><code>create</code></a> and the command-line help available with <code>--help</code>.</p><ul><li><code>argv</code>: command line to parse. Defaults to <code>Sys.argv</code>.</li><li><code>default_workers</code>: the default number of workers to use in parallel runs when <code>-j</code> or <code>--jobs</code> isn't specified on the command line. It defaults to <code>None</code>, indicating that the number of workers will be set to the number of CPUs detected on the machine.</li><li><code>expectation_workspace_root</code>: storage path for expected output. The default is <code>tests/snapshots</code>.</li><li><code>handle_subcommand_result</code>: optional function to call on the result of the subcommand before exiting. It can be used to export test results to a specific format.</li><li><code>status_workspace_root</code>: storage path for test results. The default is <code>_build/testo/status</code>.</li><li><code>project_name</code>: name of the program as shown in the <code>--help</code> page and used as a folder name for storing test results.</li></ul></div></div></div></body></html>
