<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lazy_with_output (testo.Testo.Lazy_with_output)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">testo</a> &#x00BB; <a href="../index.html">Testo</a> &#x00BB; Lazy_with_output</nav><header class="odoc-preamble"><h1>Module <code><span>Testo.Lazy_with_output</span></code></h1><p><b>EXPERIMENTAL</b> Lazy computations that capture and restore stdout/stderr.</p><p>This is intended to save computation time when multiple tests share the same preliminary, costly computation.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p><b>EXPERIMENTAL</b></p><p>A lazy computation similar to OCaml's <code>Lazy.t</code> that also captures and restores stdout and stderr output just like it catches, stores and re-raises exceptions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-redirect"><a href="#type-redirect" class="anchor"></a><code><span><span class="keyword">type</span> redirect</span><span> = </span></code><ol><li id="type-redirect.Stdout_to_stderr" class="def variant constructor anchored"><a href="#type-redirect.Stdout_to_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Stdout_to_stderr</span></span></code></li><li id="type-redirect.Stderr_to_stdout" class="def variant constructor anchored"><a href="#type-redirect.Stderr_to_stdout" class="anchor"></a><code><span>| </span><span><span class="constructor">Stderr_to_stdout</span></span></code></li></ol></div><div class="spec-doc"><p><code>Stdout_to_stderr</code> cause all stdout output to be printed on stderr. <code>Stderr_to_stdout</code> is the other way around.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span class="optlabel">?redirect</span>:<a href="#type-redirect">redirect</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><b>EXPERIMENTAL</b></p><p>Store a lazy computation. This doesn't compute it yet.</p><p>During the computation, Stdout and stderr outputs are captured separately, then printed out one after the other, with stdout coming first before stderr. To preserve the original interleaving of standard output and error output as it would normally appear in a console, use a redirect from stdout to stderr or vice-versa with the <code>redirect</code> option so as to merge the two streams into one for the duration of the computation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-force"><a href="#val-force" class="anchor"></a><code><span><span class="keyword">val</span> force : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Promise/index.html#type-t">Promise.t</a></span></span></code></div><div class="spec-doc"><p><b>EXPERIMENTAL</b></p><p>Run the lazy computation if it hasn't run yet. If the computation was already performed, the original standard and error outputs are printed again. The original result is returned or the original exception is re-raised with the original stack backtrace if applicable.</p></div></div></div></body></html>
