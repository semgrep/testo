<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Testo (testo.Testo)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">testo</a> &#x00BB; Testo</nav><header class="odoc-preamble"><h1>Module <code><span>Testo</span></code></h1><p>Testo library - Utilities for writing OCaml test suites</p></header><nav class="odoc-toc"><ul><li><a href="#internal-types">Internal types</a></li><li><a href="#main-interface">Main interface</a><ul><li><a href="#test-creation">Test creation</a></li><li><a href="#output-masking-functions">Output masking functions</a></li><li><a href="#inline-tests">Inline tests</a></li><li><a href="#categorization-and-filtering-of-test-suites">Categorization and filtering of test suites</a></li><li><a href="#conversion-to-alcotest-test-suites">Conversion to Alcotest test suites</a></li><li><a href="#command-line-interpretation">Command-line interpretation</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="internal-types"><a href="#internal-types" class="anchor"></a>Internal types</h2><p>These types are documented in the library's source code in <code>Types.ml</code>. They are subject to frequent and unannounced changes at the whim of the library's authors. A casual user should not need them.</p><div class="odoc-spec"><div class="spec type anchored" id="type-expected_outcome"><a href="#type-expected_outcome" class="anchor"></a><code><span><span class="keyword">type</span> expected_outcome</span><span> = </span></code><ol><li id="type-expected_outcome.Should_succeed" class="def variant constructor anchored"><a href="#type-expected_outcome.Should_succeed" class="anchor"></a><code><span>| </span><span><span class="constructor">Should_succeed</span></span></code></li><li id="type-expected_outcome.Should_fail" class="def variant constructor anchored"><a href="#type-expected_outcome.Should_fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Should_fail</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>explains why we expect this test to fail</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-outcome"><a href="#type-outcome" class="anchor"></a><code><span><span class="keyword">type</span> outcome</span><span> = </span></code><ol><li id="type-outcome.Succeeded" class="def variant constructor anchored"><a href="#type-outcome.Succeeded" class="anchor"></a><code><span>| </span><span><span class="constructor">Succeeded</span></span></code></li><li id="type-outcome.Failed" class="def variant constructor anchored"><a href="#type-outcome.Failed" class="anchor"></a><code><span>| </span><span><span class="constructor">Failed</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-captured_output"><a href="#type-captured_output" class="anchor"></a><code><span><span class="keyword">type</span> captured_output</span><span> = </span></code><ol><li id="type-captured_output.Ignored" class="def variant constructor anchored"><a href="#type-captured_output.Ignored" class="anchor"></a><code><span>| </span><span><span class="constructor">Ignored</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>unchecked combined output</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_stdout" class="def variant constructor anchored"><a href="#type-captured_output.Captured_stdout" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_stdout</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stdout, unchecked output</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_stderr" class="def variant constructor anchored"><a href="#type-captured_output.Captured_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_stderr</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stderr, unchecked output</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_stdout_stderr" class="def variant constructor anchored"><a href="#type-captured_output.Captured_stdout_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_stdout_stderr</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stdout, stderr</p><span class="comment-delim">*)</span></div></li><li id="type-captured_output.Captured_merged" class="def variant constructor anchored"><a href="#type-captured_output.Captured_merged" class="anchor"></a><code><span>| </span><span><span class="constructor">Captured_merged</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>combined output</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expected_output"><a href="#type-expected_output" class="anchor"></a><code><span><span class="keyword">type</span> expected_output</span><span> = </span></code><ol><li id="type-expected_output.Ignored" class="def variant constructor anchored"><a href="#type-expected_output.Ignored" class="anchor"></a><code><span>| </span><span><span class="constructor">Ignored</span></span></code></li><li id="type-expected_output.Expected_stdout" class="def variant constructor anchored"><a href="#type-expected_output.Expected_stdout" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_stdout</span> <span class="keyword">of</span> string</span></code></li><li id="type-expected_output.Expected_stderr" class="def variant constructor anchored"><a href="#type-expected_output.Expected_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_stderr</span> <span class="keyword">of</span> string</span></code></li><li id="type-expected_output.Expected_stdout_stderr" class="def variant constructor anchored"><a href="#type-expected_output.Expected_stdout_stderr" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_stdout_stderr</span> <span class="keyword">of</span> string * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>stdout, stderr</p><span class="comment-delim">*)</span></div></li><li id="type-expected_output.Expected_merged" class="def variant constructor anchored"><a href="#type-expected_output.Expected_merged" class="anchor"></a><code><span>| </span><span><span class="constructor">Expected_merged</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>combined output</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-result"><a href="#type-result" class="anchor"></a><code><span><span class="keyword">type</span> result</span><span> = </span><span>{</span></code><ol><li id="type-result.outcome" class="def record field anchored"><a href="#type-result.outcome" class="anchor"></a><code><span>outcome : <a href="#type-outcome">outcome</a>;</span></code></li><li id="type-result.captured_output" class="def record field anchored"><a href="#type-result.captured_output" class="anchor"></a><code><span>captured_output : <a href="#type-captured_output">captured_output</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-missing_files"><a href="#type-missing_files" class="anchor"></a><code><span><span class="keyword">type</span> missing_files</span><span> = </span></code><ol><li id="type-missing_files.Missing_files" class="def variant constructor anchored"><a href="#type-missing_files.Missing_files" class="anchor"></a><code><span>| </span><span><span class="constructor">Missing_files</span> <span class="keyword">of</span> <span>string list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expectation"><a href="#type-expectation" class="anchor"></a><code><span><span class="keyword">type</span> expectation</span><span> = </span><span>{</span></code><ol><li id="type-expectation.expected_outcome" class="def record field anchored"><a href="#type-expectation.expected_outcome" class="anchor"></a><code><span>expected_outcome : <a href="#type-expected_outcome">expected_outcome</a>;</span></code></li><li id="type-expectation.expected_output" class="def record field anchored"><a href="#type-expectation.expected_output" class="anchor"></a><code><span>expected_output : <span><span>(<a href="#type-expected_output">expected_output</a>, <a href="#type-missing_files">missing_files</a>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> status</span><span> = </span><span>{</span></code><ol><li id="type-status.expectation" class="def record field anchored"><a href="#type-status.expectation" class="anchor"></a><code><span>expectation : <a href="#type-expectation">expectation</a>;</span></code></li><li id="type-status.result" class="def record field anchored"><a href="#type-status.result" class="anchor"></a><code><span>result : <span><span>(<a href="#type-result">result</a>, <a href="#type-missing_files">missing_files</a>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-fail_reason"><a href="#type-fail_reason" class="anchor"></a><code><span><span class="keyword">type</span> fail_reason</span><span> = </span></code><ol><li id="type-fail_reason.Exception" class="def variant constructor anchored"><a href="#type-fail_reason.Exception" class="anchor"></a><code><span>| </span><span><span class="constructor">Exception</span></span></code></li><li id="type-fail_reason.Wrong_output" class="def variant constructor anchored"><a href="#type-fail_reason.Wrong_output" class="anchor"></a><code><span>| </span><span><span class="constructor">Wrong_output</span></span></code></li><li id="type-fail_reason.Exception_and_wrong_output" class="def variant constructor anchored"><a href="#type-fail_reason.Exception_and_wrong_output" class="anchor"></a><code><span>| </span><span><span class="constructor">Exception_and_wrong_output</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status_class"><a href="#type-status_class" class="anchor"></a><code><span><span class="keyword">type</span> status_class</span><span> = </span></code><ol><li id="type-status_class.PASS" class="def variant constructor anchored"><a href="#type-status_class.PASS" class="anchor"></a><code><span>| </span><span><span class="constructor">PASS</span></span></code></li><li id="type-status_class.FAIL" class="def variant constructor anchored"><a href="#type-status_class.FAIL" class="anchor"></a><code><span>| </span><span><span class="constructor">FAIL</span> <span class="keyword">of</span> <a href="#type-fail_reason">fail_reason</a></span></code></li><li id="type-status_class.XFAIL" class="def variant constructor anchored"><a href="#type-status_class.XFAIL" class="anchor"></a><code><span>| </span><span><span class="constructor">XFAIL</span> <span class="keyword">of</span> <a href="#type-fail_reason">fail_reason</a></span></code></li><li id="type-status_class.XPASS" class="def variant constructor anchored"><a href="#type-status_class.XPASS" class="anchor"></a><code><span>| </span><span><span class="constructor">XPASS</span></span></code></li><li id="type-status_class.MISS" class="def variant constructor anchored"><a href="#type-status_class.MISS" class="anchor"></a><code><span>| </span><span><span class="constructor">MISS</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status_summary"><a href="#type-status_summary" class="anchor"></a><code><span><span class="keyword">type</span> status_summary</span><span> = </span><span>{</span></code><ol><li id="type-status_summary.status_class" class="def record field anchored"><a href="#type-status_summary.status_class" class="anchor"></a><code><span>status_class : <a href="#type-status_class">status_class</a>;</span></code></li><li id="type-status_summary.has_expected_output" class="def record field anchored"><a href="#type-status_summary.has_expected_output" class="anchor"></a><code><span>has_expected_output : bool;</span></code></li></ol><code><span>}</span></code></div></div><h2 id="main-interface"><a href="#main-interface" class="anchor"></a>Main interface</h2><h3 id="test-creation"><a href="#test-creation" class="anchor"></a>Test creation</h3><div class="odoc-spec"><div class="spec type anchored" id="type-checked_output_kind"><a href="#type-checked_output_kind" class="anchor"></a><code><span><span class="keyword">type</span> checked_output_kind</span></code></div><div class="spec-doc"><p>This type specifies what part of the output of a test (stdout, stderr) should be captured and compared against expectations.</p><p>Use the provided functions <a href="#val-stdout"><code>stdout</code></a>, <a href="#val-stderr"><code>stderr</code></a>, <a href="#val-stdxxx"><code>stdxxx</code></a>, and <a href="#val-split_stdout_stderr"><code>split_stdout_stderr</code></a> to create such an object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <span><span class="optlabel">?expected_stdout_path</span>:string <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Create an object of type <a href="#type-checked_output_kind"><code>checked_output_kind</code></a> specifying that the test's standard output must be checked against a reference file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <span><span class="optlabel">?expected_stderr_path</span>:string <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-stdout"><code>stdout</code></a> but for capturing stderr instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stdxxx"><a href="#val-stdxxx" class="anchor"></a><code><span><span class="keyword">val</span> stdxxx : <span><span class="optlabel">?expected_stdxxx_path</span>:string <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-stdout"><code>stdout</code></a> but for capturing the combined stdout and stderr outputs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_stdout_stderr"><a href="#val-split_stdout_stderr" class="anchor"></a><code><span><span class="keyword">val</span> split_stdout_stderr : 
  <span><span class="optlabel">?expected_stdout_path</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_stderr_path</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-checked_output_kind">checked_output_kind</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-stdxxx"><code>stdxxx</code></a> but keep stdout and stderr separate.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Promise/index.html">Promise</a></span></code></div><div class="spec-doc"><p>Wrapper allowing for asynchronous test functions (Lwt and such).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Tag"><a href="#module-Tag" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Tag/index.html">Tag</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Tag/index.html">Tag</a></span></code></div><div class="spec-doc"><p>The type of tags which can be used to define subsets of tests precisely.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> </span><span>{</span></code><ol><li id="type-t.id" class="def record field anchored"><a href="#type-t.id" class="anchor"></a><code><span>id : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Hash of the full name of the test, computed automatically.</p><span class="comment-delim">*)</span></div></li><li id="type-t.internal_full_name" class="def record field anchored"><a href="#type-t.internal_full_name" class="anchor"></a><code><span>internal_full_name : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Full name of the test, derived automatically from category and name.</p><span class="comment-delim">*)</span></div></li><li id="type-t.category" class="def record field anchored"><a href="#type-t.category" class="anchor"></a><code><span>category : <span>string list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Categories are made for organizing tests as a tree which is useful for display and filtering. A new category is created typically when grouping multiple test suites into one with 'categorize_suites' or when assigning a category to a list of tests with 'categorize'. e.g. <code>&quot;food&quot;; &quot;fruit&quot;; &quot;kiwi&quot;</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.name" class="def record field anchored"><a href="#type-t.name" class="anchor"></a><code><span>name : string;</span></code></li><li id="type-t.func" class="def record field anchored"><a href="#type-t.func" class="anchor"></a><code><span>func : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>;</span></code></li><li id="type-t.expected_outcome" class="def record field anchored"><a href="#type-t.expected_outcome" class="anchor"></a><code><span>expected_outcome : <a href="#type-expected_outcome">expected_outcome</a>;</span></code></li><li id="type-t.tags" class="def record field anchored"><a href="#type-t.tags" class="anchor"></a><code><span>tags : <span><a href="Tag/index.html#type-t">Tag.t</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tags must be declared once using 'create_tag'.</p><span class="comment-delim">*)</span></div></li><li id="type-t.normalize" class="def record field anchored"><a href="#type-t.normalize" class="anchor"></a><code><span>normalize : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An optional function to rewrite any output data so as to mask the variable parts.</p><span class="comment-delim">*)</span></div></li><li id="type-t.checked_output" class="def record field anchored"><a href="#type-t.checked_output" class="anchor"></a><code><span>checked_output : <a href="#type-checked_output_kind">checked_output_kind</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The 'skipped' property causes a test to be skipped by Alcotest but still shown as &quot;<code>SKIP</code>&quot; rather than being omitted.</p><span class="comment-delim">*)</span></div></li><li id="type-t.skipped" class="def record field anchored"><a href="#type-t.skipped" class="anchor"></a><code><span>skipped : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If the test function changes the current directory without restoring it, it's an error unless this flag is set.</p><span class="comment-delim">*)</span></div></li><li id="type-t.tolerate_chdir" class="def record field anchored"><a href="#type-t.tolerate_chdir" class="anchor"></a><code><span>tolerate_chdir : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>All the tests in a test suite should share this field.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p><code>t</code> is the type of a test. A test suite is a flat list of tests.</p><p>A test is at a minimum a name and a test function that raises exceptions to signal test failure. It is created with <a href="#val-create"><code>create</code></a> or other similar functions provided by this module.</p><p>There are two main recommended ways of writing the test function:</p><p>1. With <code>assert false</code>:</p><p>Each test may use <code>assert false</code> to indicate that the test doesn't pass. This is the simplest way of failing while also showing the location of the failure. When using <code>assert false</code>, you should generally take care of printing the expected value and actual value to make debugging easier later.</p><p>2. With <code>Alcotest.(check ...)</code>:</p><p>This is a little nicer because the error messages print something like <code>&quot;Expecting 'foo', got 'bar'&quot;</code>. However, this can make tests slightly more complicated to write. If the test already prints the expected value and the actual value as its output, it's just easier to fail with <code>assert false</code>.</p><p>In any case, Alcotest will capture the output (stdout, stderr) of each test and put it in its own file so we can consult it later. Don't hesitate to log a lot during the execution of the test.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-test_with_status"><a href="#type-test_with_status" class="anchor"></a><code><span><span class="keyword">type</span> test_with_status</span><span> = <a href="#type-t">t</a> * <a href="#type-status">status</a> * <a href="#type-status_summary">status_summary</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-subcommand_result"><a href="#type-subcommand_result" class="anchor"></a><code><span><span class="keyword">type</span> subcommand_result</span><span> = </span></code><ol><li id="type-subcommand_result.Run_result" class="def variant constructor anchored"><a href="#type-subcommand_result.Run_result" class="anchor"></a><code><span>| </span><span><span class="constructor">Run_result</span> <span class="keyword">of</span> <span><a href="#type-test_with_status">test_with_status</a> list</span></span></code></li><li id="type-subcommand_result.Status_result" class="def variant constructor anchored"><a href="#type-subcommand_result.Status_result" class="anchor"></a><code><span>| </span><span><span class="constructor">Status_result</span> <span class="keyword">of</span> <span><a href="#type-test_with_status">test_with_status</a> list</span></span></code></li><li id="type-subcommand_result.Approve_result" class="def variant constructor anchored"><a href="#type-subcommand_result.Approve_result" class="anchor"></a><code><span>| </span><span><span class="constructor">Approve_result</span></span></code></li></ol></div><div class="spec-doc"><p>The return type of each subcommand. It allows custom code to do something with the test data e.g. export to the JUnit format via the optional <code>handle_subcommand_result</code> argument of <code>interpret_argv</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span><span class="optlabel">?category</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?checked_output</span>:<a href="#type-checked_output_kind">checked_output_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_outcome</span>:<a href="#type-expected_outcome">expected_outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?normalize</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?skipped</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tags</span>:<span><a href="Tag/index.html#type-t">Tag.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tolerate_chdir</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a test to appear in a test suite.</p><ul><li><code>category</code>: the nested category to assign to the test. The category can be nested further using <a href="#val-categorize"><code>categorize</code></a> or <a href="#val-categorize_suites"><code>categorize_suites</code></a>.</li><li><code>checked_output</code>: determines how to capture the test's output. Defaults to no capture.</li><li><code>expected_outcome</code>: whether a test is expected to complete without raising an exception (default) or by raising an exception.</li><li><code>normalize</code>: a list of functions applied in turn to transform the captured output before comparing it to the reference snapshot. See <a href="#val-mask_line"><code>mask_line</code></a> and other functions with the <code>mask</code> prefix which are provided for this purpose.</li><li><code>skipped</code>: whether the test should be skipped. This is intended for tests that give inconsistent results and need fixing. See also <code>expected_outcome</code>.</li><li><code>tags</code>: a list of tags to apply to the test. See <a href="Tag/index.html"><code>Tag</code></a>.</li><li><code>tolerate_chdir</code>: by default, a test will fail if it modifies the current directory and doesn't restore it. This flag cancels this check. Note that Testo will always restore the current directory after running a test regardless of this setting.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : 
  <span><span class="optlabel">?category</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?checked_output</span>:<a href="#type-checked_output_kind">checked_output_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_outcome</span>:<a href="#type-expected_outcome">expected_outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?func</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?normalize</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?skipped</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tags</span>:<span><a href="Tag/index.html#type-t">Tag.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tolerate_chdir</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Update some of the test's fields. This ensures that the test's unique identifier <a href="#type-t.id"><code>id</code></a> is recomputed correctly. When specified, an optional property will replace the previous value.</p></div></div><h3 id="output-masking-functions"><a href="#output-masking-functions" class="anchor"></a>Output masking functions</h3><p>Functions with the <code>mask_</code> prefix are string replacement utilities to be used for masking the variable parts of test output in order to make them stable and comparable. This is for the <code>normalize</code> option of <a href="#val-create"><code>create</code></a>.</p><p>Testo will keep a copy of the original, unmasked output for the developer to consult. In particular, this masking functionality will not prevent sensitive data such as passwords or secret keys from being stored in the local file system.</p><div class="odoc-spec"><div class="spec value anchored" id="val-mask_line"><a href="#val-mask_line" class="anchor"></a><code><span><span class="keyword">val</span> mask_line : 
  <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?after</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?before</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Mask partially each line that contains <code>before</code> or <code>after</code>.</p><p>If both <code>after</code> and <code>before</code> are specified, they must occur in that order on a line to have an effect. The text between these markers is replaced by <code>mask</code>. If only <code>before</code> is specified, the portion of masked text starts at the beginning of the line. If only <code>after</code> is specified, the portion of masked text extends to the end of the line.</p><p>For example, <code>(mask_line ~after:&quot;time:&quot; ()) &quot;London time: 10:15,\nBlah&quot;</code> produces <code>&quot;London time:&lt;MASKED&gt;\nBlah&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_pcre_pattern"><a href="#val-mask_pcre_pattern" class="anchor"></a><code><span><span class="keyword">val</span> mask_pcre_pattern : 
  <span><span class="optlabel">?replace</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Mask all occurrences of this PCRE pattern. The syntax is limited to what the ocaml-re library supports.</p><p>In the case that the pattern contains a capturing group and it (the first group) matches, only this substring is replaced rather than the whole match. The default <code>replace</code> function replaces the capture by <code>&quot;&lt;MASKED&gt;&quot;</code>.</p><p>Examples:</p><pre>     (* without a capturing group: *)
     mask_pcre_pattern ~replace:(fun _ -&gt; &quot;X&quot;) {|&lt;[0-9]+&gt;|} &quot;xxx &lt;42&gt; xxx&quot;
       = &quot;xxx X xxx&quot;</pre><pre>     (* with a capturing group: *)
     mask_pcre_pattern ~replace:(fun _ -&gt; &quot;X&quot;) {|&lt;([0-9]+)&gt;|} &quot;xxx &lt;42&gt; xxx&quot;
       = &quot;xxx &lt;X&gt; xxx&quot;</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_temp_paths"><a href="#val-mask_temp_paths" class="anchor"></a><code><span><span class="keyword">val</span> mask_temp_paths : 
  <span><span class="optlabel">?depth</span>:<span>int option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?replace</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tmpdir</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Mask strings that look like temporary file paths. This is useful in the following cases:</p><ul><li>the temporary folder depends on the platform (Unix, Windows) or on the environment (TMPDIR environment variable or equivalent);</li><li>the files placed in the system's temporary folder are assigned random names.</li></ul><p>Options:</p><ul><li><code>depth</code>: maximum number of path segments to mask after <code>/tmp</code> or equivalent. For example, <code>/tmp/b4ac9882/foo/bar</code> will become <code>&lt;TMP&gt;/&lt;MASKED&gt;/foo/bar</code> with the default depth of <code>Some 1</code>. With a depth of 2, if would become <code>&lt;TMP&gt;/&lt;MASKED&gt;/&lt;MASKED&gt;/bar</code>. Use <code>None</code> to mask the full path. Use <code>Some 0</code> to mask only <code>/tmp</code> or equivalent.</li><li><code>replace</code>: function that determines what to replace the matched path with.</li><li><code>tmpdir</code>: the path to the temporary folder to use instead of the system default.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_not_substring"><a href="#val-mask_not_substring" class="anchor"></a><code><span><span class="keyword">val</span> mask_not_substring : <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Keep the given substring and mask everything else. This is for tests that only care about a particular substring being present in the output.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_not_substrings"><a href="#val-mask_not_substrings" class="anchor"></a><code><span><span class="keyword">val</span> mask_not_substrings : <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Keep all the given substrings and mask everything else.</p><p>In case of overlaps between matching substrings, priority is given to the one starting earlier. If two substrings share a prefix, the longest match is preferred.</p><p>Examples:</p><ul><li><code>[&quot;cute&quot;; &quot;exec&quot;]</code> will cause <code>&quot;execute&quot;</code> to become <code>&quot;exec&lt;MASKED&gt;&quot;</code> because <code>exec</code> occurs first in the target string.</li><li><code>[&quot;wat&quot;; &quot;water&quot;]</code> will cause <code>&quot;hard water&quot;</code> to become <code>&quot;&lt;MASKED&gt;water&quot;</code> and not <code>&quot;&lt;MASKED&gt;wat&lt;MASKED&gt;&quot;</code> because <code>water</code> is a longer match than <code>wat</code> starting at the same position.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mask_not_pcre_pattern"><a href="#val-mask_not_pcre_pattern" class="anchor"></a><code><span><span class="keyword">val</span> mask_not_pcre_pattern : <span><span class="optlabel">?mask</span>:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Keep the substrings that match the given PCRE pattern and mask everything else.</p></div></div><h3 id="inline-tests"><a href="#inline-tests" class="anchor"></a>Inline tests</h3><div class="odoc-spec"><div class="spec value anchored" id="val-test"><a href="#val-test" class="anchor"></a><code><span><span class="keyword">val</span> test : 
  <span><span class="optlabel">?category</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?checked_output</span>:<a href="#type-checked_output_kind">checked_output_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expected_outcome</span>:<a href="#type-expected_outcome">expected_outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?normalize</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?skipped</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tags</span>:<span><a href="Tag/index.html#type-t">Tag.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?tolerate_chdir</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add a test to the global test suite that can be recovered with <a href="#val-get_registered_tests"><code>get_registered_tests</code></a>.</p><p>This mechanism supports only synchronous tests i.e. ordinary tests whose test function has type <code>unit -&gt; unit</code>.</p><p>It is meant to declare inline tests as follows:</p><pre>     let () = Testo.test &quot;foo&quot; (fun () -&gt;
       (* test body raising exceptions to signal failure *)
       ...
     )</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_registered_tests"><a href="#val-get_registered_tests" class="anchor"></a><code><span><span class="keyword">val</span> get_registered_tests : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Recover the list of tests registered with <a href="#val-test"><code>test</code></a>.</p></div></div><h3 id="categorization-and-filtering-of-test-suites"><a href="#categorization-and-filtering-of-test-suites" class="anchor"></a>Categorization and filtering of test suites</h3><p>A Testo test suite is a flat list of test cases. However, each test belongs to a category. Categories can be arbitrarily nested and can be exported as a tree if desired.</p><div class="odoc-spec"><div class="spec value anchored" id="val-categorize"><a href="#val-categorize" class="anchor"></a><code><span><span class="keyword">val</span> categorize : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Put a list of tests into a parent category.</p><p>Usage:</p><pre>     let apple_tests =
       categorize &quot;apples&quot; [test_color; test_juiciness]</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-categorize_suites"><a href="#val-categorize_suites" class="anchor"></a><code><span><span class="keyword">val</span> categorize_suites : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="#type-t">t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Variant of <a href="#val-categorize"><code>categorize</code></a> that flattens the nested list first.</p><pre>     let fruit_tests =
       categorize_suites &quot;fruit&quot; [apple_tests; banana_tests; strawberry_tests]</pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p>Sort tests by category and name, alphabetically.</p><p>Non-ASCII path components are currently sorted by byte order, possibly giving unexpected results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_tag"><a href="#val-has_tag" class="anchor"></a><code><span><span class="keyword">val</span> has_tag : <span><a href="Tag/index.html#type-t">Tag.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Whether a test has this tag. This is meant for filtering test suites.</p></div></div><h3 id="conversion-to-alcotest-test-suites"><a href="#conversion-to-alcotest-test-suites" class="anchor"></a>Conversion to Alcotest test suites</h3><div class="odoc-spec"><div class="spec type anchored" id="type-alcotest_test_case"><a href="#type-alcotest_test_case" class="anchor"></a><code><span><span class="keyword">type</span> alcotest_test_case</span><span> =
  string * <span>[ `Quick <span>| `Slow</span> ]</span> * <span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span>)</span></span></code></div><div class="spec-doc"><p>A type alias for Alcotest test cases.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-alcotest_test"><a href="#type-alcotest_test" class="anchor"></a><code><span><span class="keyword">type</span> alcotest_test</span><span> = string * <span><a href="#type-alcotest_test_case">alcotest_test_case</a> list</span></span></code></div><div class="spec-doc"><p>A type alias for an Alcotest <code>test</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_alcotest"><a href="#val-to_alcotest" class="anchor"></a><code><span><span class="keyword">val</span> to_alcotest : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-alcotest_test">alcotest_test</a> list</span></span></code></div><div class="spec-doc"><p>Export our tests to a list of tests that can run in Alcotest. This removes the ability to store test outcomes or to check the test output against expectations. Tests that are expected to fail and indeed fail (XFAIL) will be treated as successful by Alcotest. Conversely, tests that fail to raise an exception (XPASS) will be shown as failed by Alcotest.</p><p>This function is provided to facilitate migrations between Alcotest and Testo, not for long-term use.</p></div></div><h3 id="command-line-interpretation"><a href="#command-line-interpretation" class="anchor"></a>Command-line interpretation</h3><div class="odoc-spec"><div class="spec value anchored" id="val-interpret_argv"><a href="#val-interpret_argv" class="anchor"></a><code><span><span class="keyword">val</span> interpret_argv : 
  <span><span class="optlabel">?argv</span>:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?expectation_workspace_root</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?handle_subcommand_result</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subcommand_result">subcommand_result</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?status_workspace_root</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">project_name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="Promise/index.html#type-t">Promise.t</a></span></span></code></div><div class="spec-doc"><p>Launch the command-line interface. It provides subcommands for running the tests, for checking test statuses, and for approving new output.</p><p>Return value: exit code reflecting overall success or failure (0 or 1), and subcommand-specific data for export to JUnit or similar.</p><ul><li><code>argv</code>: command line to parse. Defaults to <code>Sys.argv</code>.</li><li><code>expectation_workspace_root</code>: storage path for expected output. The default is <code>tests/snapshots</code>.</li><li><code>handle_subcommand_result</code>: optional function to call on the result of the subcommand before exiting. It can be used to export test results to a specific format.</li><li><code>status_workspace_root</code>: storage path for test results. The default is <code>_build/testo/status</code>.</li><li><code>project_name</code>: name of the program as shown in the <code>--help</code> page and used as a folder name for storing test results.</li></ul></div></div></div></body></html>
